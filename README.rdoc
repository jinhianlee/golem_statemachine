= Golem Statemachine

Golem adds {Finite State Machine (FSM)}[http://en.wikipedia.org/wiki/Finite_state_machine] behaviour to Ruby classes. 

Ruby objects with Finite State Machine behaviour are always in some given state, and are allowed to transition between states based on the rules that define your FSM. The golem_statemachine library provides a simple DSL (domain-specific language) for defining the FSM rules. It is designed specifically with ActiveRecord in mind, but should work with any Ruby object.

For example, you might want to implement an approval workflow process for a Document class. The Document has five possible states: 'NEW', 'SUBMITTED', 'REJECTED', 'REVISED', 'APPROVED', and three possible events: 'submit', 'review', 'revise'. NEW and REVISED documents can be submitted, SUBMITTED documents can be reviewed, and REJECTED documents can be revised.

Here is the Golem Statemachine definition for this state machine:

  require 'golem'

  class Document
    attr_accessor :state

    def initialize
      @has_signature = false
    end

    def sign!
      @has_signature = true
    end

    def has_signature?
      @has_signature
    end

    include Golem
    define_statemachine do
      initial_state :NEW

      state :NEW do
        on :submit, :to => :SUBMITTED
      end

      state :SUBMITTED do
        on :review do
          transition :to => :APPROVED, :if => :has_signature?
          transition :to => :REJECTED
        end
      end

      state :REJECTED do
        on :revise, :to => :REVISED
      end

      state :REVISED do
        on :submit, :to => :SUBMITTED
      end

      state :APPROVED
    end
  end


Now we can instantiate a Document and use it like so:

  doc = Document.new
  doc.submit!
  puts doc.state # ==> :SUBMITTED
  doc.review!
  puts doc.state # ==> :REJECTED
  doc.revise!
  puts doc.state # ==> :REVISED
  doc.sign!
  doc.submit!
  doc.review!
  puts doc.state # ==> :APPROVED

For a more complicated example, see <tt>examples/seminar_enrollment.rb</tt>.


== Installation

Install as a Rails plugin:

  script/plugin install git://github.com/zuk/golem_statemachine.git

Use it in your model:
  
  class Example < ActiveRecord::Base

    include Golem

    define_statemachine do
      # ... write your statemachine definition ...
    end

  end

Make sure that the underlying SQL table has a 'state' column of type string.
If you want to store the state in a different column, use <tt>current_state_from</tt> like this:

  define_statemachine do
    current_state_from :status

    # ...
  end


== Golem vs. AASM

There is already another popular FSM implementation for Ruby -- {rubyist's AASM}[http://github.com/rubyist/aasm] (also known as acts_as_state_machine). Golem was developed from scratch as an alternative to AASM, with the intention of a better DSL and cleaner, easier to read code. 

Golem's DSL is centered around States rather than Events; this makes Golem statemachines easier to visualize in UML (and vice-versa). Golem's DSL also implements the decision pseudostate (a concept taken from UML), making complicated business logic easier to implement.

Golem's code is also more modular and more consistent, which will hopefully make extending the DSL easier.
